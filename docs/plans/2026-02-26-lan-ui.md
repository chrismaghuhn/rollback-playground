# Godot Demo LAN UI + Connection State — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Extend `game/RollbackDemo.cs` with a mode switch (Offline / LAN), a LAN panel (Host, Join, Disconnect, IP, Port, status), a two-state machine (`DemoMode` / `LanState`), and a physics gate that freezes the engine while waiting for a peer — all without touching any `Core.*` project or adding any networking code.

**Architecture:** Single-file extension of the existing `Node2D` script. Two private nested enums (`DemoMode`, `LanState`) drive visibility and gate logic. `_simulationRunning` is the single gate flag: `true` in Offline mode always; `true` in LAN mode only when `Connected`. Engine is re-created with the correct `LocalPlayer` when Host or Join is clicked. No `PacketCodec` usage, no UDP, no `SetRemoteInput` over wire.

**Tech Stack:** Godot 4.6.1 / C# / .NET 8, `game/game.csproj`

---

### Task 1: Enums, state fields, physics gate, extended debug label

**Files:**
- Modify: `game/RollbackDemo.cs`

Adds the entire state skeleton — enums, fields, physics gate, extended debug text. No new UI nodes yet. Offline mode must behave exactly as before after this task.

**Step 1: Add enums inside the class**

After the `ColHpBg` color constant (after line 43), insert:

```csharp
// ─── Mode / connection state ──────────────────────────────────────────────

/// <summary>Top-level demo mode.</summary>
private enum DemoMode { Offline, Lan }

/// <summary>LAN connection lifecycle state.</summary>
private enum LanState { Disconnected, Hosting, Joining, Connected }
```

**Step 2: Add state fields**

After the `_lagLbl` field declaration (after line 50), add a new group:

```csharp
// ─── Mode + LAN connection state ─────────────────────────────────────────

private DemoMode    _mode              = DemoMode.Offline;
private LanState    _lanState          = LanState.Disconnected;
private string      _remoteIp          = "127.0.0.1";
private int         _port              = 7777;
private LocalPlayer _localPlayer       = LocalPlayer.P1;
/// <summary>
/// True when the simulation should advance each physics tick.
/// Always true in Offline mode; true in LAN mode only when Connected.
/// The physics gate in _PhysicsProcess reads this flag.
/// </summary>
private bool        _simulationRunning = true;
```

**Step 3: Forward `_localPlayer` to engine in `_Ready`**

Replace the engine-construction line (line 54):

```csharp
// BEFORE:
_engine = new RollbackEngine(SimState.CreateInitial(Seed), HistoryCap);

// AFTER:
_engine = new RollbackEngine(SimState.CreateInitial(Seed), HistoryCap, _localPlayer);
```

Behaviour is identical since `_localPlayer` defaults to `LocalPlayer.P1`.

**Step 4: Add physics gate at the top of `_PhysicsProcess`**

Replace the entire `_PhysicsProcess` method:

```csharp
public override void _PhysicsProcess(double delta)
{
    // In LAN mode, do not advance the simulation until we are Connected.
    // Prediction-debt would accumulate while waiting; gating here prevents it.
    if (!_simulationRunning)
    {
        UpdateDebugLabel();
        QueueRedraw();
        return;
    }

    uint f = _engine.CurrentFrame;

    FrameInput p1 = ReadP1Input();   // 1. Poll local input
    EnqueueP2(f);                    // 2. Generate + schedule P2's real input
    DeliverDue(f);                   // 3. Deliver any inputs due this frame (may rollback)
    _engine.Tick(p1);               // 4. Advance sim
    UpdateDebugLabel();             // 5. Refresh HUD text
    QueueRedraw();                  // 6. Request _Draw
}
```

**Step 5: Update `UpdateDebugLabel` to include mode / role / LAN state**

Replace the entire `UpdateDebugLabel` method:

```csharp
private void UpdateDebugLabel()
{
    uint justSimulated = _engine.CurrentFrame == 0u ? 0u : _engine.CurrentFrame - 1u;
    bool confirmedForJustSimulated =
        _latestRemoteFrame != uint.MaxValue &&
        _latestRemoteFrame >= justSimulated;

    string remoteStatus    = _latestRemoteFrame == uint.MaxValue ? "N/A "
                           : confirmedForJustSimulated            ? "CONF" : "PRED";
    string latestRemoteTxt = _latestRemoteFrame == uint.MaxValue
                           ? "    ---"
                           : $"{_latestRemoteFrame,7}";

    string lanLines = _mode == DemoMode.Lan
        ? $"LAN State:     {_lanState}\n"
        + (_lanState != LanState.Connected ? "               ⏳ Waiting for peer…\n" : "")
        : "";

    _debugLbl.Text =
        $"Mode:            {(_mode == DemoMode.Offline ? "Offline" : "LAN")}\n"  +
        $"LocalPlayer:     {(_localPlayer == LocalPlayer.P1 ? "P1" : "P2")}\n"   +
        lanLines                                                                   +
        $"Frame:          {_engine.CurrentFrame,7}\n"                             +
        $"LatestRemote:  {latestRemoteTxt}\n"                                     +
        $"Remote:        {remoteStatus,7}\n"                                      +
        $"RollbackCount: {_engine.RollbackCount,7}\n"                             +
        $"MaxRollback:   {_engine.MaxRollbackDepth,7} frames\n"                   +
        $"FramesRolled:  {_engine.RollbackFramesTotal,7}\n"                       +
        $"DelayFrames:   {_delayFrames,7}";
}
```

**Step 6: Build — expect 0 errors, 0 warnings**

```bash
dotnet build game/game.csproj -c Release
```
Expected: `Build succeeded.` — 0 error(s), 0 warning(s).

**Step 7: Commit**

```bash
git add game/RollbackDemo.cs
git commit -m "feat(game): add DemoMode/LanState enums, state fields, and simulation gate"
```

---

### Task 2: Mode-switch buttons + LAN panel UI + wired callbacks

**Files:**
- Modify: `game/RollbackDemo.cs`

Adds all Godot UI nodes: two-button mode switch (Offline / LAN) at top-center, LAN panel (status label / IP / Port / action buttons) at top-right. Wires all button callbacks. Existing lag slider is stored as `_lagRow` so it can be hidden in LAN mode.

**Step 1: Add UI field declarations**

After the `_lagLbl` field declaration (after `private Label _lagLbl = null!;`), add:

```csharp
// ─── LAN UI controls ──────────────────────────────────────────────────────

private HBoxContainer _lagRow        = null!;   // reference so we can toggle visibility
private VBoxContainer _lanPanel      = null!;
private Label         _lanStatusLbl  = null!;
private Button        _hostBtn       = null!;
private Button        _joinBtn       = null!;
private Button        _disconnectBtn = null!;
private LineEdit      _ipField       = null!;
private SpinBox       _portSpinBox   = null!;
```

**Step 2: Replace `BuildUi` to store `_lagRow` and call new builders**

Replace the entire `BuildUi` method:

```csharp
private void BuildUi()
{
    _hud = new CanvasLayer();
    AddChild(_hud);

    // Debug label — top-left, fixed monospace readout
    _debugLbl = new Label();
    _debugLbl.Position = new Vector2(8f, 8f);
    _debugLbl.AddThemeFontSizeOverride("font_size", 14);
    _hud.AddChild(_debugLbl);
    UpdateDebugLabel();

    // Mode switch — top-center (Offline | LAN)
    BuildModeSwitch();

    // Lag slider row — top-right, visible in Offline mode only
    _lagLbl = new Label { Text = "0 frames" };

    var slider = new HSlider();
    slider.MinValue          = 0;
    slider.MaxValue          = 10;
    slider.Step              = 1;
    slider.Value             = 0;
    slider.CustomMinimumSize = new Vector2(160f, 20f);
    slider.ValueChanged     += v =>
    {
        _delayFrames = (int)v;
        _lagLbl.Text = $"{(int)v} frames";
    };

    var lagHeaderLbl = new Label { Text = "Lag: " };

    _lagRow = new HBoxContainer();
    _lagRow.Position = new Vector2(ViewportW - 280f, 8f);
    _lagRow.AddChild(lagHeaderLbl);
    _lagRow.AddChild(slider);
    _lagRow.AddChild(_lagLbl);
    _hud.AddChild(_lagRow);

    // LAN panel — top-right, visible in LAN mode only (hidden initially)
    BuildLanPanel();
}
```

**Step 3: Add `BuildModeSwitch` method**

Add after `BuildUi`:

```csharp
private void BuildModeSwitch()
{
    var offlineBtn = new Button { Text = "Offline" };
    var lanBtn     = new Button { Text = "LAN" };

    offlineBtn.Pressed += () => SwitchMode(DemoMode.Offline);
    lanBtn.Pressed     += () => SwitchMode(DemoMode.Lan);

    var row = new HBoxContainer();
    row.Position = new Vector2(ViewportW / 2f - 50f, 8f);
    row.AddChild(offlineBtn);
    row.AddChild(lanBtn);
    _hud.AddChild(row);
}
```

**Step 4: Add `BuildLanPanel` method**

Add after `BuildModeSwitch`:

```csharp
private void BuildLanPanel()
{
    _lanPanel = new VBoxContainer();
    _lanPanel.Position = new Vector2(ViewportW - 320f, 8f);
    _lanPanel.Visible  = false; // hidden until LAN mode is active
    _hud.AddChild(_lanPanel);

    // Status label — shows DISCONNECTED / HOSTING / JOINING / CONNECTED
    _lanStatusLbl = new Label { Text = "State: DISCONNECTED" };
    _lanPanel.AddChild(_lanStatusLbl);

    // Address row: IP + Port
    _ipField = new LineEdit { Text = _remoteIp, CustomMinimumSize = new Vector2(120f, 0f) };
    _ipField.TextChanged += t => _remoteIp = t;

    _portSpinBox = new SpinBox();
    _portSpinBox.MinValue          = 1;
    _portSpinBox.MaxValue          = 65535;
    _portSpinBox.Value             = _port;
    _portSpinBox.CustomMinimumSize = new Vector2(80f, 0f);
    _portSpinBox.ValueChanged     += v => _port = (int)v;

    var addrRow = new HBoxContainer();
    addrRow.AddChild(new Label { Text = "IP " });
    addrRow.AddChild(_ipField);
    addrRow.AddChild(new Label { Text = " Port " });
    addrRow.AddChild(_portSpinBox);
    _lanPanel.AddChild(addrRow);

    // Action buttons
    _hostBtn       = new Button { Text = "Host" };
    _joinBtn       = new Button { Text = "Join" };
    _disconnectBtn = new Button { Text = "Disconnect" };

    _hostBtn.Pressed       += OnHost;
    _joinBtn.Pressed       += OnJoin;
    _disconnectBtn.Pressed += OnDisconnect;

    var btnRow = new HBoxContainer();
    btnRow.AddChild(_hostBtn);
    btnRow.AddChild(_joinBtn);
    btnRow.AddChild(_disconnectBtn);
    _lanPanel.AddChild(btnRow);
}
```

**Step 5: Add `SwitchMode`, `OnHost`, `OnJoin`, `OnDisconnect` callback methods**

Add after `BuildLanPanel`:

```csharp
/// <summary>
/// Switches the top-level demo mode. Offline: shows lag slider, resets engine to P1.
/// LAN: hides lag slider, shows LAN panel in Disconnected state.
/// </summary>
private void SwitchMode(DemoMode newMode)
{
    if (_mode == newMode) return;
    _mode = newMode;

    if (newMode == DemoMode.Offline)
    {
        _lanState          = LanState.Disconnected;
        _localPlayer       = LocalPlayer.P1;
        _simulationRunning = true;
        // Reset engine and lag-simulation state so Offline starts cleanly.
        _engine            = new RollbackEngine(SimState.CreateInitial(Seed), HistoryCap);
        _lagBuffer.Clear();
        _latestRemoteFrame = uint.MaxValue;
    }
    else // Lan
    {
        _lanState          = LanState.Disconnected;
        _simulationRunning = false;
        _lanStatusLbl.Text = "State: DISCONNECTED";
    }

    _lagRow.Visible   = (newMode == DemoMode.Offline);
    _lanPanel.Visible = (newMode == DemoMode.Lan);
    UpdateDebugLabel();
}

/// <summary>
/// Host button: become P1, enter Hosting state, freeze simulation until peer connects.
/// Re-creates the engine so both sides start from the same initial state.
/// </summary>
private void OnHost()
{
    _lanState          = LanState.Hosting;
    _localPlayer       = LocalPlayer.P1;
    _simulationRunning = false;
    _engine            = new RollbackEngine(SimState.CreateInitial(Seed), HistoryCap, _localPlayer);
    _lagBuffer.Clear();
    _latestRemoteFrame = uint.MaxValue;
    _lanStatusLbl.Text = "State: HOSTING  (waiting for peer)";
    UpdateDebugLabel();
}

/// <summary>
/// Join button: become P2, enter Joining state, freeze simulation until host connects.
/// Re-creates the engine so both sides start from the same initial state.
/// </summary>
private void OnJoin()
{
    _lanState          = LanState.Joining;
    _localPlayer       = LocalPlayer.P2;
    _simulationRunning = false;
    _engine            = new RollbackEngine(SimState.CreateInitial(Seed), HistoryCap, _localPlayer);
    _lagBuffer.Clear();
    _latestRemoteFrame = uint.MaxValue;
    _lanStatusLbl.Text = "State: JOINING  (waiting for host)";
    UpdateDebugLabel();
}

/// <summary>
/// Disconnect button: return to Disconnected sub-state.
/// Freezes the simulation at its current frame (does not reset engine).
/// </summary>
private void OnDisconnect()
{
    _lanState          = LanState.Disconnected;
    _simulationRunning = false;
    _lanStatusLbl.Text = "State: DISCONNECTED";
    UpdateDebugLabel();
}
```

**Step 6: Build — expect 0 errors, 0 warnings**

```bash
dotnet build game/game.csproj -c Release
```
Expected: `Build succeeded.` — 0 error(s), 0 warning(s).

**Step 7: Commit**

```bash
git add game/RollbackDemo.cs
git commit -m "feat(game): add LAN panel UI, mode switch, and connection callbacks"
```

---

### Task 3: Final verification + push + tag

**Step 1: Full game build with warnings-as-errors**

```bash
dotnet build game/game.csproj -c Release -warnaserror
```
Expected: Build succeeded, 0 errors, 0 warnings.

**Step 2: Full solution build — verify Core.* projects unaffected**

```bash
dotnet build RollbackPlayground.sln -warnaserror
```
Expected: Build succeeded, all projects 0 errors, 0 warnings.

**Step 3: Run full test suite — verify 78 tests still pass**

```bash
dotnet test RollbackPlayground.sln --logger "console;verbosity=minimal"
```
Expected: **78 passed, 0 failed, 0 skipped**

**Step 4: Push commits**

```bash
git push
```

**Step 5: Tag and push**

```bash
git tag v0.3-2-task2
git push origin v0.3-2-task2
```
